// nolint
package gen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"os"
	"path"
	"slices"
	"sort"
	"strconv"
	"strings"

	"github.com/pixality-inc/golang-core/logger"
	"github.com/pixality-inc/golang-core/util"

	"github.com/gobeam/stringy"
	"gopkg.in/yaml.v3"
)

var disclaimer = "Code generated by gen. DO NOT EDIT."

var (
	errDirectoryDoesNotExist          = errors.New("directory does not exist")
	errFailedToParseImport            = errors.New("failed to parse import for file")
	errInvalidJSONField               = errors.New("invalid json field")
	errInvalidEnumField               = errors.New("invalid enum field")
	errEnumNotFound                   = errors.New("invalid enum field: no such enum")
	errInvalidFieldType               = errors.New("invalid field type")
	errUnsupportedFieldType           = errors.New("unsupported field type")
	errReferencesMustContainTwoValues = errors.New("references property must contain 2 values only")
)

type Config struct {
	ProjectId       string
	Dir             string
	DaoDir          string
	MigrationsDir   string
	DocsDir         string
	ApiDir          string
	ProtoFilename   string
	ApiModelsPrefix string
	ApiPackageName  string
	ApiEnums        ApiEnums
	ApiModels       ApiModels
}

func NewConfig(
	projectId string,
	dir string,
	daoDir string,
	migrationsDir string,
	docsDir string,
	apiDir string,
	protoFilename string,
	apiModelsPrefix string,
	apiPackageName string,
	apiEnums ApiEnums,
	apiModels ApiModels,
) *Config {
	return &Config{
		ProjectId:       projectId,
		Dir:             dir,
		DaoDir:          daoDir,
		MigrationsDir:   migrationsDir,
		DocsDir:         docsDir,
		ApiDir:          apiDir,
		ProtoFilename:   protoFilename,
		ApiModelsPrefix: apiModelsPrefix,
		ApiPackageName:  apiPackageName,
		ApiEnums:        apiEnums,
		ApiModels:       apiModels,
	}
}

type enumResponse struct {
	sql []byte
	gen []byte
}

type fileResponse struct {
	sourceFileConfig sourceFileConfig
	model            *ModelRequest
	sql              []byte
	daoGen           []byte
	dao              []byte
}

type sourceFileField struct {
	Name       string   `json:"name"       yaml:"name"`
	Type       string   `json:"type"       yaml:"type"`
	Seq        bool     `json:"seq"        yaml:"seq"`
	Primary    bool     `json:"primary"    yaml:"primary"`
	Unique     bool     `json:"unique"     yaml:"unique"`
	Array      bool     `json:"array"      yaml:"array"`
	ArraySize  int      `json:"array_size" yaml:"array_size"`
	Nullable   bool     `json:"nullable"   yaml:"nullable"`
	Enum       string   `json:"enum"       yaml:"enum"`
	DataType   string   `json:"data_type"  yaml:"data_type"`
	Default    string   `json:"default"    yaml:"default"`
	References []string `json:"references" yaml:"references"`
}

type sourceFileConfig struct {
	Name       string            `json:"name"        yaml:"name"`
	ModelName  string            `json:"model_name"  yaml:"model_name"`
	DaoImports [][]string        `json:"dao_imports" yaml:"dao_imports"`
	Imports    [][]string        `json:"imports"     yaml:"imports"`
	Fields     []sourceFileField `json:"fields"      yaml:"fields"`
}

type enumsObject struct {
	Enums map[string][]string `json:"enums" yaml:"enums"`
}

type named struct {
	original         string
	snake            string
	camel            string
	camelCapitalized string
	alias            string
	idSuffix         string
	daoSuffix        string
	columnsSuffix    string
}

type EnumEntry struct {
	Name   string
	Values []string
}

type GenerateRequest struct {
	enumsMap map[string][]string
}

type ModelRequest struct {
	daoName   named
	modelName named
	enumsMap  map[string]named
}

type sqlField struct {
	name     string
	dataType string
	extras   string
}

func (s *sqlField) render(nameWidth int, dataTypeWidth int) []byte {
	if len(s.extras) > 0 {
		format := fmt.Sprintf("%%-%ds %%-%ds %%s", nameWidth, dataTypeWidth)

		return []byte(fmt.Sprintf(format, s.name, s.dataType, s.extras))
	} else {
		format := fmt.Sprintf("%%-%ds %%s", nameWidth)

		return []byte(fmt.Sprintf(format, s.name, s.dataType))
	}
}

type modelField struct {
	name        string
	dataType    string
	annotations string
}

//nolint:unused
func (s *modelField) render(nameWidth int, dataTypeWidth int) []byte {
	format := fmt.Sprintf("%%-%ds %%-%ds %%s", nameWidth, dataTypeWidth)

	return []byte(fmt.Sprintf(format, s.name, s.dataType, s.annotations))
}

type fieldAttribute string

var (
	fieldAttributeSequence fieldAttribute = "sequence"
	fieldAttributeUnique   fieldAttribute = "unique"
	fieldAttributeUuid     fieldAttribute = "uuid"
	fieldAttributeJson     fieldAttribute = "json"
	fieldAttributeGeometry fieldAttribute = "geometry"
	fieldAttributeTime     fieldAttribute = "time"
	fieldAttributeNullable fieldAttribute = "nullable"
)

type entityField struct {
	name       named
	sqlField   sqlField
	modelField modelField
	attributes []fieldAttribute
}

type entityModel struct {
	modelName  named
	daoName    named
	fields     []*entityField
	attributes []fieldAttribute
}

type Gen struct {
	log    logger.Loggable
	config *Config
}

func NewGen(config *Config) *Gen {
	return &Gen{
		log:    logger.NewLoggableImplWithService("gen"),
		config: config,
	}
}

func (g *Gen) Generate(ctx context.Context) error {
	if _, ok := util.FileExists(g.config.Dir); !ok {
		return fmt.Errorf("%w: %s", errDirectoryDoesNotExist, g.config.Dir)
	}

	if err := os.MkdirAll(g.config.DaoDir, os.ModePerm); err != nil {
		return err
	}

	if err := os.MkdirAll(g.config.MigrationsDir, os.ModePerm); err != nil {
		return err
	}

	enumsFilename := path.Join(g.config.Dir, "enums.yaml")

	enumsBuf, err := os.ReadFile(enumsFilename)
	if err != nil {
		return err
	}

	var enums enumsObject

	if err = yaml.Unmarshal(enumsBuf, &enums); err != nil {
		return err
	}

	generateRequest := &GenerateRequest{
		enumsMap: enums.Enums,
	}

	if err = g.generateEnums(ctx, generateRequest); err != nil {
		return err
	}

	if err = g.generateFiles(ctx, generateRequest); err != nil {
		return err
	}

	apiFilename := path.Join(g.config.Dir, "api.yaml")

	apiBuf, err := os.ReadFile(apiFilename)
	if err != nil {
		return err
	}

	var apiSchema *ApiSchema

	if err = yaml.Unmarshal(apiBuf, &apiSchema); err != nil {
		return err
	}

	if err = g.generateApi(ctx, apiSchema, g.config.ApiEnums, g.config.ApiModels); err != nil {
		return err
	}

	if err = g.generateWeb(ctx, apiSchema, g.config.ApiEnums, g.config.ApiModels); err != nil {
		return err
	}

	return nil
}

func (g *Gen) generateEnums(ctx context.Context, request *GenerateRequest) error {
	enumsSqlFilename := path.Join(g.config.MigrationsDir, "enums_gen.sql")
	enumsGoFilename := path.Join(g.config.DaoDir, "enums_gen.go")

	enumsSql := make([]byte, 0)

	enumsSql = append(enumsSql, []byte("-- "+disclaimer+"\n\n")...)

	enumsGo := make([]byte, 0)

	enumsGo = append(enumsGo, []byte("// "+disclaimer+"\n\n")...)
	enumsGo = append(enumsGo, []byte("package dao\n\n")...)

	enumsEntries := make([]EnumEntry, 0)

	for name, values := range request.enumsMap {
		enumsEntries = append(enumsEntries, EnumEntry{
			Name:   name,
			Values: values,
		})
	}

	sort.Slice(enumsEntries, func(i, j int) bool {
		return enumsEntries[i].Name < enumsEntries[j].Name
	})

	for _, enumEntry := range enumsEntries {
		name := enumEntry.Name
		values := enumEntry.Values

		response, err := g.generateEnum(ctx, name, values)
		if err != nil {
			return fmt.Errorf("failed to generate enum '%s': %w", name, err)
		}

		enumsSql = append(enumsSql, []byte("-- "+name+"\n")...)
		enumsSql = append(enumsSql, '\n')
		enumsSql = append(enumsSql, response.sql...)
		enumsSql = append(enumsSql, '\n', '\n')

		enumsGo = append(enumsGo, []byte("// "+name+"\n")...)
		enumsGo = append(enumsGo, '\n')
		enumsGo = append(enumsGo, response.gen...)
		enumsGo = append(enumsGo, '\n')
	}

	//nolint:gosec // G306: generated file permissions are intentionally permissive
	if err := os.WriteFile(enumsSqlFilename, enumsSql, os.ModePerm); err != nil {
		return err
	}

	//nolint:gosec // G306: generated file permissions are intentionally permissive
	if err := os.WriteFile(enumsGoFilename, enumsGo, os.ModePerm); err != nil {
		return err
	}

	return nil
}

// nolint:unparam
func (g *Gen) generateEnum(ctx context.Context, name string, values []string) (*enumResponse, error) {
	log := g.log.GetLogger(ctx)

	log.Infof("Generating enum '%s'", name)

	// Sql

	var sql []byte

	{
		sql = append(sql, []byte(fmt.Sprintf("DROP TYPE IF EXISTS %s;", name))...)
		sql = append(sql, '\n', '\n')
	}

	{
		sql = append(sql, []byte(fmt.Sprintf("CREATE TYPE %s AS ENUM (", name))...)

		for idx, value := range values {
			if idx > 0 {
				sql = append(sql, ',', ' ')
			}

			sql = append(sql, []byte(fmt.Sprintf("'%s'", value))...)
		}

		sql = append(sql, []byte(");")...)
	}

	// Gen

	var gen []byte

	enumName := makeNamed(strings.ToLower(name))

	gen = append(gen, []byte(fmt.Sprintf("type %s string\n", enumName.camelCapitalized))...)
	gen = append(gen, '\n')

	{
		gen = append(gen, []byte("const (\n")...)

		for _, value := range values {
			valueName := makeNamed(value)
			quotedValue := strconv.Quote(value)
			gen = append(gen, []byte(fmt.Sprintf("\t%s%s %s = %s\n", enumName.camelCapitalized, valueName.camelCapitalized, enumName.camelCapitalized, quotedValue))...)
		}

		gen = append(gen, []byte(")\n")...)
	}

	{
		gen = append(gen, '\n')
		gen = append(gen, []byte(fmt.Sprintf("var %sValues = []%s{\n", enumName.camelCapitalized, enumName.camelCapitalized))...)

		for _, value := range values {
			valueName := makeNamed(value)
			gen = append(gen, []byte(fmt.Sprintf("\t%s%s,\n", enumName.camelCapitalized, valueName.camelCapitalized))...)
		}

		gen = append(gen, []byte("}\n")...)
	}

	{
		gen = append(gen, '\n')
		gen = append(gen, []byte(fmt.Sprintf("var %sMap = map[string]%s{\n", enumName.camelCapitalized, enumName.camelCapitalized))...)

		for _, value := range values {
			valueName := makeNamed(value)
			quotedValue := strconv.Quote(value)
			gen = append(gen, []byte(fmt.Sprintf("\t%s: %s%s,\n", quotedValue, enumName.camelCapitalized, valueName.camelCapitalized))...)
		}

		gen = append(gen, []byte("}\n")...)
	}

	// Response

	response := &enumResponse{
		sql: sql,
		gen: gen,
	}

	return response, nil
}

func (g *Gen) generateFiles(ctx context.Context, request *GenerateRequest) error {
	sourceDaoDir := path.Join(g.config.Dir, "dao")

	entries, err := os.ReadDir(sourceDaoDir)
	if err != nil {
		return err
	}

	files := make([]string, 0)

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		filename := path.Join(sourceDaoDir, entry.Name())

		files = append(files, filename)
	}

	for _, file := range files {
		basename := path.Base(file)

		if strings.HasPrefix(basename, ".") || strings.HasPrefix(basename, "~") || strings.HasSuffix(basename, "~") {
			continue
		}

		response, err := g.generateFile(ctx, request, file)
		if err != nil {
			return fmt.Errorf("failed to generate file '%s': %w", file, err)
		}

		sqlFilename := path.Join(g.config.MigrationsDir, response.model.daoName.snake+"_gen.sql")

		//nolint:gosec // G306: generated file permissions are intentionally permissive
		if err = os.WriteFile(sqlFilename, response.sql, os.ModePerm); err != nil {
			return err
		}

		daoGenFilename := path.Join(g.config.DaoDir, response.model.daoName.snake+"_gen.go")

		//nolint:gosec // G306: generated file permissions are intentionally permissive
		if err = os.WriteFile(daoGenFilename, response.daoGen, os.ModePerm); err != nil {
			return err
		}

		daoFilename := path.Join(g.config.DaoDir, response.model.daoName.snake+".go")

		if _, ok := util.FileExists(daoFilename); !ok {
			//nolint:gosec // G306: generated file permissions are intentionally permissive
			if err = os.WriteFile(daoFilename, response.dao, os.ModePerm); err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *Gen) generateFile(ctx context.Context, request *GenerateRequest, filename string) (*fileResponse, error) {
	g.log.GetLogger(ctx).Infof("Generating file '%s'", filename)

	sourceFile, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var sourceConfig sourceFileConfig

	if err := yaml.Unmarshal(sourceFile, &sourceConfig); err != nil {
		return nil, err
	}

	modelRequest := &ModelRequest{
		daoName:   makeNamed(sourceConfig.Name),
		modelName: makeNamed(sourceConfig.ModelName),
		enumsMap:  make(map[string]named),
	}

	for name := range request.enumsMap {
		modelRequest.enumsMap[name] = makeNamed(strings.ToLower(name))
	}

	model, err := g.generateModel(modelRequest, sourceConfig)
	if err != nil {
		return nil, err
	}

	// Names

	modelName := modelRequest.modelName.camelCapitalized
	modelsName := modelRequest.daoName.camelCapitalized

	daoName := modelRequest.daoName.camelCapitalized + "Dao"
	daoImplName := daoName + "Impl"
	getterName := modelName + "Getter"
	setterName := modelName + "Setter"
	implName := modelName + "Impl"
	newName := "New" + modelName
	rowName := modelRequest.modelName.camel + "Row"
	tableColumnsName := modelsName + "TableColumns"
	tableNameName := modelsName + "TableName"
	tableName := modelsName + "Table"
	convertName := "convert" + modelName + "RowToModel"

	// Model

	var modelGen []byte

	{
		{
			// Getter
			buf := make([]byte, 0)

			buf = append(buf, []byte("type "+getterName+" interface {\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\tGet"+field.modelField.name+"() "+field.modelField.dataType+"\n")...)
			}

			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// Setter
			buf := make([]byte, 0)

			buf = append(buf, []byte("type "+setterName+" interface {\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\tSet"+field.modelField.name+"(value "+field.modelField.dataType+")\n")...)
			}

			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// Impl
			buf := make([]byte, 0)

			buf = append(buf, []byte("type "+implName+" struct {\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\t"+field.name.camel+" "+field.modelField.dataType+" "+field.modelField.annotations+"\n")...)
			}

			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// Row
			buf := make([]byte, 0)

			buf = append(buf, []byte("type "+rowName+" struct {\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\t"+field.modelField.name+" "+field.modelField.dataType+" "+field.modelField.annotations+"\n")...)
			}

			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// New
			buf := make([]byte, 0)

			buf = append(buf, []byte("func "+newName+"(\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\t"+field.name.camel+" "+field.modelField.dataType+",\n")...)
			}

			buf = append(buf, []byte(") *"+implName+" {\n")...)
			buf = append(buf, []byte("\treturn &"+implName+"{\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\t\t"+field.name.camel+": "+field.name.camel+",\n")...)
			}

			buf = append(buf, []byte("\t}\n")...)
			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// Convert
			buf := make([]byte, 0)

			buf = append(buf, []byte("func "+convertName+"(row "+rowName+") "+modelName+" {\n")...)
			buf = append(buf, []byte("\treturn &"+implName+"{\n")...)

			for _, field := range model.fields {
				buf = append(buf, []byte("\t\t"+field.name.camel+": row."+field.modelField.name+",\n")...)
			}

			buf = append(buf, []byte("\t}\n")...)
			buf = append(buf, '}', '\n', '\n')

			modelGen = append(modelGen, buf...)
		}

		{
			// Bindings for Impl
			buf := make([]byte, 0)

			for _, field := range model.fields {
				buf = append(buf, []byte("func (m *"+implName+") Get"+field.modelField.name+"() "+field.modelField.dataType+"{\n")...)
				buf = append(buf, []byte("\treturn m."+field.name.camel+"\n")...)
				buf = append(buf, []byte("}\n")...)
				buf = append(buf, '\n')
			}

			for _, field := range model.fields {
				buf = append(buf, []byte("func (m *"+implName+") Set"+field.modelField.name+"(value "+field.modelField.dataType+") {\n")...)
				buf = append(buf, []byte("\tm."+field.name.camel+" = value\n")...)
				buf = append(buf, []byte("}\n")...)
				buf = append(buf, '\n')
			}

			modelGen = append(modelGen, buf...)
		}
	}

	// Dao

	var daoGen []byte

	{
		// TableColumns
		buf := make([]byte, 0)

		buf = append(buf, []byte("type "+tableColumnsName+" struct {\n")...)

		for _, field := range model.fields {
			buf = append(buf, []byte("\t"+field.modelField.name+" string\n")...)
		}

		buf = append(buf, '}', '\n', '\n')

		daoGen = append(daoGen, buf...)
	}

	{
		quotedTableName := strconv.Quote(modelRequest.daoName.snake)

		// TableName
		buf := make([]byte, 0)

		buf = append(buf, []byte("var "+tableNameName+"  = "+quotedTableName+" \n")...)
		buf = append(buf, '\n', '\n')

		daoGen = append(daoGen, buf...)
	}

	{
		// Table
		buf := make([]byte, 0)

		buf = append(buf, []byte("var "+tableName+"  = "+tableColumnsName+" {\n")...)

		for _, field := range model.fields {
			buf = append(buf, []byte("\t"+field.modelField.name+": "+field.sqlField.name+",\n")...)
		}

		buf = append(buf, '}', '\n', '\n')

		daoGen = append(daoGen, buf...)
	}

	// Columns

	{
		buf := make([]byte, 0)

		buf = append(buf, []byte("var "+modelRequest.daoName.columnsSuffix+" = []string{\n")...)

		for _, field := range model.fields {
			buf = append(buf, '\t')
			buf = append(buf, []byte(tableName+"."+field.modelField.name)...)
			buf = append(buf, ',')
			buf = append(buf, '\n')
		}

		buf = append(buf, '}', '\n', '\n')

		daoGen = append(daoGen, buf...)
	}

	{
		daoFormat := `type %sImpl struct {
	tableName       string
	queryBuilder    *squirrel.StatementBuilderType
	baseSelectQuery func(columns ...string) squirrel.SelectBuilder
	baseInsertQuery func() squirrel.InsertBuilder
	baseUpdateQuery func() squirrel.UpdateBuilder
	insertColumns   []postgres.GetterInsertColumn[%s]
}`

		daoGen = append(daoGen, []byte(fmt.Sprintf(daoFormat, modelRequest.daoName.daoSuffix, modelName))...)
	}

	// NewDao

	var newDaoGen []byte

	{
		var newDaoFieldsGen []byte

		for _, field := range model.fields {
			fieldFormat := `			postgres.NewGetterInsertColumn(%s.%s, func(o %s) any { return o.Get%s() }),`

			newDaoFieldsGen = append(newDaoFieldsGen, []byte(fmt.Sprintf(
				fieldFormat,
				tableName,
				field.modelField.name,
				modelName,
				field.modelField.name,
			))...)

			newDaoFieldsGen = append(newDaoFieldsGen, '\n')
		}

		newDaoFormat := `func New%s(queryBuilder *squirrel.StatementBuilderType) %s {
	tableName := %s

	return &%sImpl{
		tableName: tableName,
		queryBuilder: queryBuilder,
		baseSelectQuery: func(columns ...string) squirrel.SelectBuilder {
			if len(columns) == 0 {
				return queryBuilder.Select(%s...).From(tableName)
			} else {
				return queryBuilder.Select(columns...).From(tableName)
			}
		},
		baseInsertQuery: func() squirrel.InsertBuilder {
			return queryBuilder.Insert(tableName)
		},
		baseUpdateQuery: func() squirrel.UpdateBuilder {
			return queryBuilder.Update(tableName)
		},
		insertColumns: []postgres.GetterInsertColumn[%s]{
%s		},
	}
}`

		newDaoGen = append(newDaoGen, []byte(fmt.Sprintf(
			newDaoFormat,
			modelRequest.daoName.daoSuffix,
			modelRequest.daoName.daoSuffix,
			tableNameName,
			modelRequest.daoName.daoSuffix,
			modelRequest.daoName.columnsSuffix,
			modelName,
			string(newDaoFieldsGen),
		))...)
	}

	// Dao Gen Imports

	var daoGenImportsGen []byte

	{
		imports := [][]string{
			{"", "github.com/pixality-inc/squirrel"},
			{"", "github.com/pixality-inc/golang-core/postgres"},
		}

		for _, imp := range sourceConfig.DaoImports {
			if len(imp) != 2 {
				return nil, fmt.Errorf("%w: '%+v' for '%s'", errFailedToParseImport, imp, filename)
			}

			imports = append(imports, imp)
		}

		if slices.Contains(model.attributes, fieldAttributeUuid) {
			if bytes.Contains(modelGen, []byte("uuid.")) {
				imports = append(imports, []string{"", "github.com/google/uuid"})
			}
		}

		if slices.Contains(model.attributes, fieldAttributeTime) {
			if bytes.Contains(modelGen, []byte("time.")) {
				imports = append(imports, []string{"", "time"})
			}
		}

		if slices.Contains(model.attributes, fieldAttributeNullable) {
			if bytes.Contains(modelGen, []byte("sql.")) {
				imports = append(imports, []string{"", "database/sql"})
			}
		}

		if len(imports) > 0 {
			sort.Slice(imports, func(i, j int) bool {
				return imports[i][1] < imports[j][1]
			})

			daoGenImportsGen = append(daoGenImportsGen, []byte("import (\n")...)

			for _, imp := range imports {
				quoted := strconv.Quote(imp[1])

				daoGenImportsGen = append(daoGenImportsGen, '\t')

				if imp[0] != "" {
					daoGenImportsGen = append(daoGenImportsGen, []byte(imp[0]+" "+quoted)...)
				} else {
					daoGenImportsGen = append(daoGenImportsGen, []byte(quoted)...)
				}

				daoGenImportsGen = append(daoGenImportsGen, '\n')
			}

			daoGenImportsGen = append(daoGenImportsGen, []byte(")")...)
		}
	}

	// Dao Imports

	var daoImportsGen []byte

	{
		imports := [][]string{
			{"", "context"},
			{"", "fmt"},
			{"", "github.com/pixality-inc/squirrel"},
			{"", "github.com/pixality-inc/golang-core/util"},
			{"", "github.com/pixality-inc/golang-core/postgres"},
		}

		for _, imp := range sourceConfig.Imports {
			if len(imp) != 2 {
				return nil, fmt.Errorf("%w: '%+v' for '%s'", errFailedToParseImport, imp, filename)
			}

			imports = append(imports, imp)
		}

		if len(imports) > 0 {
			sort.Slice(imports, func(i, j int) bool {
				return imports[i][1] < imports[j][1]
			})

			daoImportsGen = append(daoImportsGen, []byte("import (\n")...)

			for _, imp := range imports {
				quoted := strconv.Quote(imp[1])

				daoImportsGen = append(daoImportsGen, '\t')

				if imp[0] != "" {
					daoImportsGen = append(daoImportsGen, []byte(imp[0]+" "+quoted)...)
				} else {
					daoImportsGen = append(daoImportsGen, []byte(quoted)...)
				}

				daoImportsGen = append(daoImportsGen, '\n')
			}

			daoImportsGen = append(daoImportsGen, []byte(")")...)
		}
	}

	// Dao

	var daoCreateGen []byte

	{
		format := `func (d *%s) Create(ctx context.Context, queryRunner postgres.QueryRunner, a %s) error {
  query, err := postgres.BuildSimpleInsertQuery(d.baseInsertQuery(), d.insertColumns, a)

	if err != nil {
		return fmt.Errorf("sql failed to build insert for query %%v: %%w", query, err)
	}

	if err := postgres.ExecuteQuery(ctx, queryRunner, query); err != nil {
		return err
	}

	return nil
}`

		daoCreateGen = append(daoCreateGen, []byte(fmt.Sprintf(
			format,
			daoImplName,
			modelName,
		))...)
	}

	var daoCreateBatchGen []byte

	{
		format := `func (d *%s) CreateBatch(ctx context.Context, queryRunner postgres.QueryRunner, arr []%s) error {
	query, err := postgres.BuildBulkInsertQuery(d.baseInsertQuery(), d.insertColumns, arr)

	if err != nil {
		return fmt.Errorf("sql failed to build insert for query %%v: %%w", query, err)
	}

	if err := postgres.ExecuteQuery(ctx, queryRunner, query); err != nil {
		return err
	}

	return nil
}`

		daoCreateBatchGen = append(daoCreateBatchGen, []byte(fmt.Sprintf(
			format,
			daoImplName,
			modelName,
		))...)
	}

	var daoListGen []byte

	{
		format := `func (d *%s) List(ctx context.Context, queryRunner postgres.QueryRunner) ([]%s, error) {
	query := d.baseSelectQuery()

	var rows []%s

	if err := postgres.ExecuteQueryRows(ctx, queryRunner, query, &rows); err != nil {
		return nil, err
	}

	return util.MapSimple(rows, %s), nil
}`

		daoListGen = append(daoListGen, []byte(fmt.Sprintf(
			format,
			daoImplName,
			modelName,
			rowName,
			convertName,
		))...)
	}

	var daoGetByIdGen []byte

	{
		format := `func (d *%s) GetById(ctx context.Context, queryRunner postgres.QueryRunner, id int64) (%s, error) {
	query := d.baseSelectQuery().
		Where(squirrel.Eq{"id": id}).
		Limit(1)

	var rows []%s

	if err := postgres.ExecuteQueryRows(ctx, queryRunner, query, &rows); err != nil {
		return nil, err
	}

	convertedRows := util.MapSimple(rows, %s)

	if len(rows) > 0 {
		return convertedRows[0], nil
	} else {
		return nil, postgres.ErrNoRows
	}
}`

		daoGetByIdGen = append(daoGetByIdGen, []byte(fmt.Sprintf(
			format,
			daoImplName,
			modelName,
			rowName,
			convertName,
		))...)
	}

	// Response

	var resultSqlGen []byte

	{
		resultSqlGen = append(resultSqlGen, []byte("-- "+disclaimer+"\n\n")...)

		quotedTableName := strconv.Quote(modelRequest.daoName.snake)

		for _, field := range model.fields {
			if slices.Contains(field.attributes, fieldAttributeSequence) {
				sequenceNameQuoted := strconv.Quote(model.daoName.snake + "_" + field.name.snake + "_seq")

				resultSqlGen = append(resultSqlGen, []byte("DROP SEQUENCE IF EXISTS "+sequenceNameQuoted+";")...)
				resultSqlGen = append(resultSqlGen, '\n', '\n')
				resultSqlGen = append(resultSqlGen, []byte("CREATE SEQUENCE IF NOT EXISTS "+sequenceNameQuoted+";")...)
				resultSqlGen = append(resultSqlGen, '\n', '\n')
			}
		}

		resultSqlGen = append(resultSqlGen, []byte("DROP TABLE IF EXISTS "+quotedTableName+";")...)
		resultSqlGen = append(resultSqlGen, '\n', '\n')
		resultSqlGen = append(resultSqlGen, []byte("CREATE TABLE IF NOT EXISTS "+quotedTableName+" (\n")...)

		maxNameWidth := 0
		maxDataTypeWidth := 0

		for _, field := range model.fields {
			if len(field.sqlField.name) > maxNameWidth {
				maxNameWidth = len(field.sqlField.name)
			}

			if len(field.sqlField.dataType) > maxDataTypeWidth {
				maxDataTypeWidth = len(field.sqlField.dataType)
			}
		}

		for idx, field := range model.fields {
			resultSqlGen = append(resultSqlGen, '\t')
			resultSqlGen = append(resultSqlGen, field.sqlField.render(maxNameWidth, maxDataTypeWidth)...)

			if idx != len(model.fields)-1 {
				resultSqlGen = append(resultSqlGen, ',')
			}

			resultSqlGen = append(resultSqlGen, '\n')
		}

		resultSqlGen = append(resultSqlGen, []byte(");\n")...)

		resultSqlGen = append(resultSqlGen, '\n')

		for _, field := range model.fields {
			if slices.Contains(field.attributes, fieldAttributeUnique) {
				uniqueIndexNameQuoted := strconv.Quote(model.daoName.snake + "_" + field.name.snake + "_idx")
				tableNameQuoted := strconv.Quote(model.daoName.snake)
				fieldNameQuoted := strconv.Quote(field.name.snake)

				resultSqlGen = append(resultSqlGen, []byte("DROP INDEX IF EXISTS "+uniqueIndexNameQuoted+";")...)
				resultSqlGen = append(resultSqlGen, '\n', '\n')
				resultSqlGen = append(resultSqlGen, []byte("CREATE UNIQUE INDEX IF NOT EXISTS "+uniqueIndexNameQuoted+" ON "+tableNameQuoted+" ("+fieldNameQuoted+");")...)
				resultSqlGen = append(resultSqlGen, '\n', '\n')
			}
		}
	}

	var resultDaoGen []byte

	{
		resultDaoGen = append(resultDaoGen, []byte("// "+disclaimer+"\n\n")...)
		resultDaoGen = append(resultDaoGen, []byte("package dao\n\n")...)

		if len(daoGenImportsGen) > 0 {
			resultDaoGen = append(resultDaoGen, daoGenImportsGen...)
			resultDaoGen = append(resultDaoGen, '\n', '\n')
		}

		resultDaoGen = append(resultDaoGen, modelGen...)
		resultDaoGen = append(resultDaoGen, '\n', '\n')
		resultDaoGen = append(resultDaoGen, daoGen...)
		resultDaoGen = append(resultDaoGen, '\n', '\n')
		resultDaoGen = append(resultDaoGen, newDaoGen...)
		resultDaoGen = append(resultDaoGen, '\n')
	}

	var resultDao []byte

	{
		resultDao = append(resultDao, []byte("package dao\n\n")...)

		if len(daoImportsGen) > 0 {
			resultDao = append(resultDao, daoImportsGen...)
			resultDao = append(resultDao, '\n', '\n')
		}

		{
			resultDao = append(resultDao, []byte(fmt.Sprintf(
				`type %s interface {
	%sGetter
}

`,
				modelRequest.modelName.camelCapitalized,
				modelRequest.modelName.camelCapitalized,
			))...)
		}

		{
			resultDao = append(resultDao, []byte(fmt.Sprintf(
				`type %s interface {
	Create(ctx context.Context, queryRunner postgres.QueryRunner, a %s) error
	CreateBatch(ctx context.Context, queryRunner postgres.QueryRunner, arr []%s) error
	List(ctx context.Context, queryRunner postgres.QueryRunner) ([]%s, error)
	GetById(ctx context.Context, queryRunner postgres.QueryRunner, id int64) (%s, error)
}
`,
				modelRequest.daoName.daoSuffix,
				modelRequest.modelName.camelCapitalized,
				modelRequest.modelName.camelCapitalized,
				modelRequest.modelName.camelCapitalized,
				modelRequest.modelName.camelCapitalized,
			))...)
			resultDao = append(resultDao, '\n')
		}

		if len(daoCreateGen) > 0 {
			resultDao = append(resultDao, daoCreateGen...)
			resultDao = append(resultDao, '\n', '\n')
		}

		if len(daoCreateBatchGen) > 0 {
			resultDao = append(resultDao, daoCreateBatchGen...)
			resultDao = append(resultDao, '\n', '\n')
		}

		if len(daoListGen) > 0 {
			resultDao = append(resultDao, daoListGen...)
			resultDao = append(resultDao, '\n', '\n')
		}

		if len(daoGetByIdGen) > 0 {
			resultDao = append(resultDao, daoGetByIdGen...)
			resultDao = append(resultDao, '\n', '\n')
		}
	}

	response := &fileResponse{
		sourceFileConfig: sourceConfig,
		model:            modelRequest,
		sql:              resultSqlGen,
		daoGen:           resultDaoGen,
		dao:              resultDao,
	}

	return response, nil
}

func (g *Gen) generateModel(modelRequest *ModelRequest, sourceConfig sourceFileConfig) (*entityModel, error) {
	entityFields := make([]*entityField, 0)

	attributesMap := make(map[fieldAttribute]bool)

	for _, field := range sourceConfig.Fields {
		resultField, err := g.generateModelField(modelRequest, field)
		if err != nil {
			return nil, fmt.Errorf("failed to generate model field '%s': %w", field.Name, err)
		}

		if len(resultField.attributes) > 0 {
			for _, attr := range resultField.attributes {
				attributesMap[attr] = true
			}
		}

		entityFields = append(entityFields, resultField)
	}

	attributes := make([]fieldAttribute, len(attributesMap))
	n := 0

	for attr := range attributesMap {
		attributes[n] = attr

		n++
	}

	model := &entityModel{
		modelName:  modelRequest.modelName,
		daoName:    modelRequest.daoName,
		fields:     entityFields,
		attributes: attributes,
	}

	return model, nil
}

func (g *Gen) generateModelField(modelRequest *ModelRequest, field sourceFileField) (*entityField, error) {
	fieldName := makeNamed(field.Name)

	var attributes []fieldAttribute

	if field.Seq {
		attributes = append(attributes, fieldAttributeSequence)
	}

	if field.Unique {
		attributes = append(attributes, fieldAttributeUnique)
	}

	if field.Nullable {
		attributes = append(attributes, fieldAttributeNullable)
	}

	nullableDataTypeOrDefault := func(def string) string {
		if field.DataType != "" {
			return "*" + field.DataType
		} else {
			return def
		}
	}

	dataTypeOrDefault := func(def string) string {
		if field.DataType != "" {
			return field.DataType
		} else {
			return def
		}
	}

	var (
		modelDataType string
		sqlDataType   string
	)

	sqlExtras := make([]string, 0)

	switch field.Type {
	case "int64":
		sqlDataType = "BIGINT"
		modelDataType = dataTypeOrDefault("int64")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*int64")
		}
	case "int32":
		sqlDataType = "INT"
		modelDataType = dataTypeOrDefault("int")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*int")
		}
	case "uint64":
		sqlDataType = "INT"
		modelDataType = dataTypeOrDefault("uint64")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*uint64")
		}
	case "uint32":
		sqlDataType = "INT"
		modelDataType = dataTypeOrDefault("uint32")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*uint32")
		}
	case "string":
		sqlDataType = "TEXT"
		modelDataType = dataTypeOrDefault("string")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*string")
		}
	case "text":
		sqlDataType = "TEXT"
		modelDataType = dataTypeOrDefault("string")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*string")
		}
	case "bool":
		sqlDataType = "BOOLEAN"
		modelDataType = dataTypeOrDefault("bool")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*bool")
		}
	case "uuid":
		attributes = append(attributes, fieldAttributeUuid)
		sqlDataType = "UUID"
		modelDataType = dataTypeOrDefault("uuid.UUID")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*" + modelDataType)
		}
	case "json":
		if len(field.DataType) == 0 {
			return nil, fmt.Errorf("%w: '%s'", errInvalidJSONField, field.Name)
		}

		attributes = append(attributes, fieldAttributeJson)
		sqlDataType = "JSONB"
		modelDataType = "postgres.Json[" + field.DataType + "]"

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*" + modelDataType)
		}
	case "date":
		sqlDataType = "DATE"
		modelDataType = dataTypeOrDefault("time.Time")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*time.Time")
		}
	case "time":
		sqlDataType = "TIME"
		modelDataType = dataTypeOrDefault("time.Time")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*time.Time")
		}
	case "duration":
		sqlDataType = "INTERVAL"
		modelDataType = dataTypeOrDefault("time.Duration")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*time.Duration")
		}
	case "timestamp":
		attributes = append(attributes, fieldAttributeTime)
		sqlDataType = "TIMESTAMPTZ"
		modelDataType = dataTypeOrDefault("time.Time")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*time.Time")
		}
	case "enum":
		if len(field.Enum) == 0 {
			return nil, fmt.Errorf("%w: '%s'", errInvalidEnumField, field.Name)
		}

		enum, ok := modelRequest.enumsMap[field.Enum]

		if !ok {
			return nil, fmt.Errorf("%w: '%s'", errEnumNotFound, field.Name)
		}

		sqlDataType = strings.ToUpper(enum.snake)
		modelDataType = dataTypeOrDefault(enum.camelCapitalized)

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("*" + modelDataType)
		}
	case "geometry":
		attributes = append(attributes, fieldAttributeGeometry)
		sqlDataType = "GEOMETRY"
		modelDataType = dataTypeOrDefault("postgres.Geometry")

		if field.Nullable {
			modelDataType = nullableDataTypeOrDefault("sql.Null[" + modelDataType + "]")
		}
	default:
		if strings.HasPrefix(field.Type, "varchar(") {
			lengthStr := field.Type[len("varchar("):]

			if !strings.HasSuffix(lengthStr, ")") {
				return nil, fmt.Errorf("%w: '%s'", errInvalidFieldType, field.Type)
			}

			lengthStr = lengthStr[:len(lengthStr)-1]

			length, err := strconv.Atoi(lengthStr)
			if err != nil {
				return nil, fmt.Errorf("invalid field type '%s': %w", field.Type, err)
			}

			sqlDataType = "VARCHAR(" + strconv.Itoa(length) + ")"
			modelDataType = dataTypeOrDefault("string")

			if field.Nullable {
				modelDataType = nullableDataTypeOrDefault("*string")
			}
		} else {
			return nil, fmt.Errorf("%w: '%s'", errUnsupportedFieldType, field.Type)
		}
	}

	if field.Array {
		if field.ArraySize != 0 {
			arraySizeStr := strconv.Itoa(field.ArraySize)

			sqlDataType += "[" + arraySizeStr + "]"
			modelDataType = "[" + arraySizeStr + "]" + modelDataType
		} else {
			sqlDataType += "[]"
			modelDataType = "[]" + modelDataType
		}
	}

	if field.Nullable {
		sqlExtras = append(sqlExtras, "NULL")
	} else {
		sqlExtras = append(sqlExtras, "NOT", "NULL")
	}

	if field.Unique {
		sqlExtras = append(sqlExtras, "UNIQUE")
	}

	if field.Primary {
		sqlExtras = append(sqlExtras, "PRIMARY", "KEY")
	}

	if len(field.References) > 0 {
		if len(field.References) != 2 {
			return nil, fmt.Errorf("%w: got %d", errReferencesMustContainTwoValues, len(field.References))
		}

		tableNameQuoted := strconv.Quote(field.References[0])
		fieldQuoted := strconv.Quote(field.References[1])

		refStr := fmt.Sprintf("%s(%s)", tableNameQuoted, fieldQuoted)

		sqlExtras = append(sqlExtras, "REFERENCES", refStr)
	}

	if len(field.Default) > 0 {
		sqlExtras = append(sqlExtras, "DEFAULT", strings.TrimSpace(field.Default))
	}

	quotedName := strconv.Quote(fieldName.snake)

	modelAnnotations := fmt.Sprintf("`json:%s yaml:%s sql:%s`", quotedName, quotedName, quotedName)

	result := &entityField{
		name: fieldName,
		sqlField: sqlField{
			name:     strconv.Quote(fieldName.snake),
			dataType: sqlDataType,
			extras:   strings.Join(sqlExtras, " "),
		},
		modelField: modelField{
			name:        fieldName.camelCapitalized,
			dataType:    modelDataType,
			annotations: modelAnnotations,
		},
		attributes: attributes,
	}

	return result, nil
}

func capitalize(s string) string {
	return strings.ToUpper(s[0:1]) + s[1:]
}

func asAlias(s string) string {
	parts := strings.Split(s, "_")

	alias := make([]byte, len(parts))

	for n, part := range parts {
		alias[n] = part[0]
	}

	return string(alias)
}

func makeNamed(str string) named {
	stringed := stringy.New(str)

	snake := stringed.SnakeCase().Get()
	camel := stringed.CamelCase().Get()
	camelCapitalized := capitalize(camel)
	alias := asAlias(snake)
	idSuffix := camelCapitalized + "Id"
	daoSuffix := camelCapitalized + "Dao"
	columnsSuffix := camelCapitalized + "Columns"

	return named{
		original:         str,
		snake:            snake,
		camel:            camel,
		camelCapitalized: camelCapitalized,
		alias:            alias,
		idSuffix:         idSuffix,
		daoSuffix:        daoSuffix,
		columnsSuffix:    columnsSuffix,
	}
}
